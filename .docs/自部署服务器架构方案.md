# 服装计件生产管理系统 - 自部署服务器架构方案

## 1. 整体架构设计

### 1.1 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        生产环境部署                              │
└─────────────────────────────────────────────────────────────────┘
                                │
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
┌───────▼──────┐        ┌──────▼──────┐        ┌──────▼──────┐
│   管理后台     │        │   后端API    │        │   移动端     │
│  (Vue.js)    │        │ (Spring Boot) │        │  (小程序)    │
│              │        │              │        │             │
│ - Nginx      │        │ - RESTful API │        │ - 原生小程序  │
│ - Vue3 + TS  │        │ - JWT认证     │        │ - 微信登录    │
│ - Element Plus│       │ - MyBatis     │        │ - HTTP调用   │
└──────────────┘        └──────────────┘        └─────────────┘
                                │
                        ┌───────▼───────┐
                        │   MySQL数据库  │
                        │               │
                        │ - 主从复制    │
                        │ - 分库分表    │
                        │ - 定时备份    │
                        └───────────────┘
```

### 1.2 技术栈选型

**后端技术栈：**
- Spring Boot 2.7+ / Spring Security + JWT / MyBatis Plus
- MySQL 8.0 / Redis 6.0+ / Docker + Docker Compose

**前端技术栈：**
- Vue 3 + TypeScript / Element Plus / Vite / Axios

**移动端：**
- 微信小程序原生开发 / 微信登录授权 / HTTP请求调用后端API

**部署运维：**
- CentOS 8 / Ubuntu 20.04 / Nginx 1.20+ / Docker 20.10+

## 2. 后端服务架构

### 2.1 项目结构
```
garment-backend/
├── garment-common/              # 公共模块
├── garment-auth/               # 认证授权模块
├── garment-tenant/             # 租户管理模块
├── garment-production/         # 生产管理模块
├── garment-print/              # 打印服务模块
├── garment-stats/              # 统计分析模块
└── garment-admin/              # 系统管理模块
```

### 2.2 认证授权模块

```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @PostMapping("/wechat-login")
    public ApiResponse<LoginResult> wechatLogin(@RequestBody WechatLoginRequest request) {
        // 通过微信API获取用户信息
        WechatUserInfo userInfo = wechatService.getUserInfo(request.getCode());
        // 处理用户登录逻辑
        LoginResult result = authService.processWechatLogin(userInfo);
        return ApiResponse.success(result);
    }
    
    @PostMapping("/phone-login")  
    public ApiResponse<LoginResult> phoneLogin(@RequestBody PhoneLoginRequest request) {
        // 验证手机验证码
        if (!smsService.verifyCode(request.getPhone(), request.getVerifyCode())) {
            throw new BusinessException("验证码错误");
        }
        // 处理手机登录
        LoginResult result = authService.processPhoneLogin(request.getPhone(), request.getTenantCode());
        return ApiResponse.success(result);
    }
}
```

### 2.3 多租户数据隔离

```java
@Component
public class TenantInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 从JWT Token中获取租户ID
        String token = request.getHeader("Authorization");
        if (StringUtils.hasText(token) && token.startsWith("Bearer ")) {
            String jwt = token.substring(7);
            Claims claims = jwtTokenUtil.getClaimsFromToken(jwt);
            Long tenantId = claims.get("tenantId", Long.class);
            // 设置当前线程的租户上下文
            TenantContext.setCurrentTenantId(tenantId);
        }
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        TenantContext.clear();
    }
}
```

## 3. 数据库设计

### 3.1 核心表结构

```sql
-- 租户表
CREATE TABLE `tenants` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `tenant_code` varchar(32) NOT NULL COMMENT '租户编码',
  `company_name` varchar(100) NOT NULL COMMENT '企业名称',
  `contact_person` varchar(50) NOT NULL COMMENT '联系人',
  `contact_phone` varchar(20) NOT NULL COMMENT '联系电话',
  `status` enum('pending','active','suspended') DEFAULT 'pending',
  `max_users` int(11) DEFAULT 10 COMMENT '最大用户数',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_code` (`tenant_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 用户表
CREATE TABLE `users` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `phone` varchar(20) NOT NULL COMMENT '手机号',
  `name` varchar(50) NOT NULL COMMENT '姓名',
  `wechat_openid` varchar(64) DEFAULT NULL COMMENT '微信OpenID',
  `current_tenant_id` bigint(20) DEFAULT NULL COMMENT '当前租户ID',
  `status` enum('active','disabled') DEFAULT 'active',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_phone` (`phone`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 裁床订单表  
CREATE TABLE `cut_orders` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `tenant_id` bigint(20) NOT NULL,
  `order_no` varchar(50) NOT NULL COMMENT '裁床单号',
  `style_id` bigint(20) NOT NULL COMMENT '款式ID',
  `total_layers` int(11) NOT NULL COMMENT '总层数',
  `cutting_type` enum('average','segment') DEFAULT 'average',
  `size_ratio` json NOT NULL COMMENT '尺码比例',
  `total_quantity` int(11) NOT NULL COMMENT '总数量',
  `status` enum('draft','confirmed','cutting','completed') DEFAULT 'draft',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_order_no` (`tenant_id`, `order_no`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 包表
CREATE TABLE `bundles` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `tenant_id` bigint(20) NOT NULL,
  `cut_order_id` bigint(20) NOT NULL,
  `bundle_no` varchar(50) NOT NULL COMMENT '包号',
  `size` varchar(10) NOT NULL COMMENT '尺码',
  `quantity` int(11) NOT NULL COMMENT '数量',
  `qr_code` varchar(255) NOT NULL COMMENT '二维码内容',
  `status` enum('pending','in_work','completed','returned') DEFAULT 'pending',
  `progress` json DEFAULT NULL COMMENT '工序进度',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_qr_code` (`qr_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

## 4. 部署配置

### 4.1 Docker Compose配置

```yaml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root_password
      MYSQL_DATABASE: garment_production
      MYSQL_USER: garment_user
      MYSQL_PASSWORD: your_strong_password
    volumes:
      - mysql_data:/var/lib/mysql
    ports:
      - "3306:3306"

  redis:
    image: redis:6.2-alpine
    command: redis-server --requirepass your_redis_password
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"

  backend:
    build: ./garment-backend
    environment:
      SPRING_PROFILES_ACTIVE: prod
      MYSQL_HOST: mysql
      REDIS_HOST: redis
    ports:
      - "8080:8080"
    depends_on:
      - mysql
      - redis

  frontend:
    build: ./garment-frontend
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - backend

volumes:
  mysql_data:
  redis_data:
```

### 4.2 Nginx配置

```nginx
server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    root /usr/share/nginx/html;
    index index.html;
    
    # 前端静态资源
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    # API代理到后端
    location /api/ {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

## 5. 主要变更说明

### 5.1 从云开发到自部署的主要变更

**数据库变更：**
- 从云数据库MongoDB → MySQL关系型数据库
- 集合结构 → 标准SQL表结构
- 云数据库安全规则 → 应用层权限控制

**认证系统变更：**
- 云开发自定义登录 → Spring Security + JWT
- 云函数调用 → RESTful API调用
- 微信云开发SDK → 微信开放平台API

**部署方式变更：**
- 云函数 → Spring Boot应用服务器
- 云托管 → Docker容器化部署
- 云存储 → 本地文件系统/对象存储

**小程序端变更：**
- wx.cloud调用 → wx.request HTTP调用
- 云开发SDK → 标准HTTP请求封装
- 实时数据库 → WebSocket/定时轮询

### 5.2 优势对比

**自部署优势：**
- 完全控制服务器和数据
- 成本可控，适合大规模应用
- 技术栈更成熟，开发者熟悉度高
- 便于定制化开发和第三方集成

**需要考虑的问题：**
- 需要自行维护服务器运维
- 需要处理扩容、备份、监控等
- 微信小程序需要配置服务器域名
- SSL证书和HTTPS配置

这个方案将原有的云开发架构完全转换为传统的自部署服务器架构，保持了业务逻辑不变，但在技术实现上更适合企业级部署和长期维护。